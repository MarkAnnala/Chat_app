{"ast":null,"code":"/*\n initialState is the state object that we send into the redux store and can manipulate with the reducers\n */\nconst initialState = {\n  socket: null,\n  wsOnline: false,\n  socketServer: null,\n  firstWelcome: null,\n  username: null,\n  listOfDms: null,\n  listOfFriends: null\n};\n/**\n * helper function used by action type \"RESPONSE\" and action \"send_message\" to locate the correct dm object index\n * @param {array} list containing all direct messages of the user\n * @param {string} chatID used to identify the correct dm object\n *\n * @returns the index of the correct dm object\n */\n\nconst getChatIndex = (list, chatID) => {\n  let index = 0;\n\n  for (const chat of list) {\n    if (chat.chatID === chatID) {\n      return index;\n    }\n\n    index++;\n  }\n\n  return -1; // this line will only be reached if we give an invalid chatID\n};\n/**\n * performs a task depending on the action.type dispatched - acts more as a middleware for socket handling\n *\n * !!! Reducers shouldn't do sideeffects which this one does - consider this one more as a middleware than a real reducer\n *\n * @param {object} state the current state that is being held by the redux store\n * @property {object} socket contains the actual socket that we communicate with\n * @property {bool} wsOnline is true when the socket is online (used to handle disconnects/time outs)\n * @property {string} socketServer the url of server that we create a websocket with\n * @property {bool} firstWelcome used to know if we've made our first repsonse to socket after login  (TODO maybe better way)\n * @property {array} listOfMessages holds all chatroom objects\n * @property {array} listOfFriends holds all friends usernames\n * @property {string} username holds the username of logged in user\n * @param {object} action contains the type and payload\n * @property {string} action.type what kind of action should the reducer do\n * @property {object} action.payload check actions.js for what it may contain\n *\n * @returns updated state\n */\n\n\nconst socketReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"CONNECT\":\n      /* store websocket in state.socket */\n      console.log(\"connecting to ws\");\n      var firstWelcome;\n\n      if (state.firstWelcome === null) {\n        firstWelcome = true;\n      } else {\n        firstWelcome = state.firstWelcome ? true : false;\n      }\n\n      return { ...state,\n        socket: new WebSocket(state.socketServer),\n        wsOnline: true,\n        firstWelcome: firstWelcome\n      };\n\n    case \"ADDFRIEND\":\n      return { ...state,\n        listOfFriends: state.listOfFriends.concat(action.payload.username)\n      };\n\n    case \"CHAT_REQUEST\":\n      console.log(action.payload);\n      state.socket.send(JSON.stringify(action.payload));\n      return state;\n\n    case \"RESPONSE\":\n      /* if data is ack or welcome there's nothning we need to do */\n      if (action.payload.data === \"Welcome\" || action.payload.data === \"ACK\") {\n        return state;\n        /* first response */\n      } else if (action.payload.action === \"login\") {\n        /* need to respond to socket with action = login, username, and magictoken to establish connection */\n        state.socket.send(JSON.stringify(action.payload));\n        /* TODO TODO\n          This if ann else cases handles the fact that we accidentely get 2 login responses from backend right now\n          not to trigger useEffect in ChatContainer we have this case here.. TODO remove it after backend fixes it\n        */\n\n        if (state.firstWelcome === false) {\n          console.log(\"Duplicate welcome login response...\");\n          return state;\n        } else {\n          console.log(\"first welcome login response\");\n          return { ...state,\n            firstWelcome: false,\n            // no longer first welcome..\n\n            /* \n            TESTING -- TODO - HARDCODED the login object that we should get in accordance with doc\n            in accordance with doc it should be a response with action \"init_login\" but we will do \n            it here right now\n                         each user gets 2 hard coded chatrooms on login\n                        each user gets 4 hard coded friends on login\n                        user get's its username  ( not hardcoded it comes from action.payload.username )\n             */\n            listOfDms: [{\n              chatName: \"Skooben\",\n              chatID: \"1a\",\n              messages: [{\n                message: \"test\",\n                username: \"Markipie\"\n              }],\n              members: [],\n              creator: \"\"\n            }, {\n              chatName: \"Grabbarna Grus\",\n              chatID: \"2a\",\n              messages: [{\n                message: \"Axel mitt sexdjur?\",\n                username: \"Anton\"\n              }, {\n                message: \"axel e arg p√• dig\",\n                username: \"Axel\"\n              }],\n              members: [],\n              creator: \"\"\n            }],\n            listOfFriends: [\"Skooben\", \"Markipie\", \"Mustafa\", \"Pallerkan\"],\n            username: action.payload.username\n          };\n        }\n      } else {\n        const parsedData = JSON.parse(action.payload.data);\n        /* We respond differently depending on the action/type of received data */\n\n        switch (parsedData.action) {\n          case \"send_message\":\n            /* add the new msg object to the right dm object */\n            const index = getChatIndex(state.listOfDms, parsedData.chat_id);\n            return { ...state,\n              listOfDms: [...state.listOfDms, state.listOfDms[index].messages.push({\n                message: parsedData.message,\n                username: parsedData.user_id\n              })]\n            };\n\n          case \"chat_request\":\n            /* insert a new chat object to listOfDms */\n            if (parsedData.status === \"ok\") {\n              return { ...state,\n                listOfDms: [...state.listOfDms,\n                /* newly inserted object */\n                {\n                  chatName: parsedData.chat_name,\n                  chatID: parsedData.chat_id,\n                  messages: [],\n                  members: parsedData.members,\n                  creator: parsedData.creator\n                }]\n              };\n            }\n\n            return state;\n\n          default:\n            return state;\n        }\n      }\n\n    case \"DISCONNECTED\":\n      return { ...state,\n        socket: action.payload,\n        wsOnline: false,\n        firstWelcome: null,\n        listOfDms: null,\n        listOfFriends: null,\n        username: null\n      };\n\n    case \"SETSERVER\":\n      return { ...state,\n        socketServer: action.payload\n      };\n\n    case \"SENDMESSAGE\":\n      const index = getChatIndex(state.listOfDms, action.payload.chat_id);\n\n      if (index !== -1) {\n        const msgObject = action.payload;\n        state.socket.send(JSON.stringify(msgObject));\n        /* update listOfDms in state */\n\n        var updateListOfDms = state.listOfDms;\n        updateListOfDms[index].messages.push({\n          message: msgObject.message,\n          username: msgObject.user_id\n        });\n        return { ...state,\n          listOfDms: updateListOfDms\n        };\n      }\n\n      return state;\n\n    default:\n      return state;\n  }\n};\n\nexport default socketReducer;","map":{"version":3,"sources":["/Users/Mark/Documents/Skola/OSPP/adrenaline/frontend/src/reducers/socketReducer.js"],"names":["initialState","socket","wsOnline","socketServer","firstWelcome","username","listOfDms","listOfFriends","getChatIndex","list","chatID","index","chat","socketReducer","state","action","type","console","log","WebSocket","concat","payload","send","JSON","stringify","data","chatName","messages","message","members","creator","parsedData","parse","chat_id","push","user_id","status","chat_name","msgObject","updateListOfDms"],"mappings":"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","sourcesContent":["/*\n initialState is the state object that we send into the redux store and can manipulate with the reducers\n */\nconst initialState = {\n  socket: null,\n  wsOnline: false,\n  socketServer: null,\n  firstWelcome: null,\n  username: null,\n  listOfDms: null,\n  listOfFriends: null,\n};\n\n/**\n * helper function used by action type \"RESPONSE\" and action \"send_message\" to locate the correct dm object index\n * @param {array} list containing all direct messages of the user\n * @param {string} chatID used to identify the correct dm object\n *\n * @returns the index of the correct dm object\n */\nconst getChatIndex = (list, chatID) => {\n  let index = 0;\n  for (const chat of list) {\n    if (chat.chatID === chatID) {\n      return index;\n    }\n    index++;\n  }\n  return -1; // this line will only be reached if we give an invalid chatID\n};\n\n/**\n * performs a task depending on the action.type dispatched - acts more as a middleware for socket handling\n *\n * !!! Reducers shouldn't do sideeffects which this one does - consider this one more as a middleware than a real reducer\n *\n * @param {object} state the current state that is being held by the redux store\n * @property {object} socket contains the actual socket that we communicate with\n * @property {bool} wsOnline is true when the socket is online (used to handle disconnects/time outs)\n * @property {string} socketServer the url of server that we create a websocket with\n * @property {bool} firstWelcome used to know if we've made our first repsonse to socket after login  (TODO maybe better way)\n * @property {array} listOfMessages holds all chatroom objects\n * @property {array} listOfFriends holds all friends usernames\n * @property {string} username holds the username of logged in user\n * @param {object} action contains the type and payload\n * @property {string} action.type what kind of action should the reducer do\n * @property {object} action.payload check actions.js for what it may contain\n *\n * @returns updated state\n */\nconst socketReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"CONNECT\":\n      /* store websocket in state.socket */\n      console.log(\"connecting to ws\");\n      var firstWelcome;\n      if (state.firstWelcome === null) {\n        firstWelcome = true;\n      } else {\n        firstWelcome = state.firstWelcome ? true : false;\n      }\n      return {\n        ...state,\n        socket: new WebSocket(state.socketServer),\n        wsOnline: true,\n        firstWelcome: firstWelcome,\n      };\n    case \"ADDFRIEND\":\n      return {\n        ...state,\n        listOfFriends: state.listOfFriends.concat(action.payload.username),\n      };\n    case \"CHAT_REQUEST\":\n      console.log(action.payload);\n      state.socket.send(JSON.stringify(action.payload));\n      return state;\n    case \"RESPONSE\":\n      /* if data is ack or welcome there's nothning we need to do */\n      if (action.payload.data === \"Welcome\" || action.payload.data === \"ACK\") {\n        return state;\n\n        /* first response */\n      } else if (action.payload.action === \"login\") {\n        /* need to respond to socket with action = login, username, and magictoken to establish connection */\n        state.socket.send(JSON.stringify(action.payload));\n\n        /* TODO TODO\n          This if ann else cases handles the fact that we accidentely get 2 login responses from backend right now\n          not to trigger useEffect in ChatContainer we have this case here.. TODO remove it after backend fixes it\n        */\n        if (state.firstWelcome === false) {\n          console.log(\"Duplicate welcome login response...\");\n          return state;\n        } else {\n          console.log(\"first welcome login response\");\n          return {\n            ...state,\n            firstWelcome: false, // no longer first welcome..\n            /* \n            TESTING -- TODO - HARDCODED the login object that we should get in accordance with doc\n            in accordance with doc it should be a response with action \"init_login\" but we will do \n            it here right now\n\n                        each user gets 2 hard coded chatrooms on login\n                        each user gets 4 hard coded friends on login\n                        user get's its username  ( not hardcoded it comes from action.payload.username )\n\n            */\n            listOfDms: [\n              {\n                chatName: \"Skooben\",\n                chatID: \"1a\",\n                messages: [{ message: \"test\", username: \"Markipie\" }],\n                members: [],\n                creator: \"\",\n              },\n              {\n                chatName: \"Grabbarna Grus\",\n                chatID: \"2a\",\n                messages: [\n                  { message: \"Axel mitt sexdjur?\", username: \"Anton\" },\n                  { message: \"axel e arg p√• dig\", username: \"Axel\" },\n                ],\n                members: [],\n                creator: \"\",\n              },\n            ],\n            listOfFriends: [\"Skooben\", \"Markipie\", \"Mustafa\", \"Pallerkan\"],\n            username: action.payload.username,\n          };\n        }\n      } else {\n        const parsedData = JSON.parse(action.payload.data);\n\n        /* We respond differently depending on the action/type of received data */\n        switch (parsedData.action) {\n          case \"send_message\":\n            /* add the new msg object to the right dm object */\n            const index = getChatIndex(state.listOfDms, parsedData.chat_id);\n            return {\n              ...state,\n              listOfDms: [\n                ...state.listOfDms,\n                state.listOfDms[index].messages.push({\n                  message: parsedData.message,\n                  username: parsedData.user_id,\n                }),\n              ],\n            };\n          case \"chat_request\":\n            /* insert a new chat object to listOfDms */\n            if (parsedData.status === \"ok\") {\n              return {\n                ...state,\n                listOfDms: [\n                  ...state.listOfDms,\n                  /* newly inserted object */\n                  {\n                    chatName: parsedData.chat_name,\n                    chatID: parsedData.chat_id,\n                    messages: [],\n                    members: parsedData.members,\n                    creator: parsedData.creator,\n                  },\n                ],\n              };\n            }\n            return state;\n          default:\n            return state;\n        }\n      }\n\n    case \"DISCONNECTED\":\n      return {\n        ...state,\n        socket: action.payload,\n        wsOnline: false,\n        firstWelcome: null,\n        listOfDms: null,\n        listOfFriends: null,\n        username: null,\n      };\n\n    case \"SETSERVER\":\n      return { ...state, socketServer: action.payload };\n\n    case \"SENDMESSAGE\":\n      const index = getChatIndex(state.listOfDms, action.payload.chat_id);\n\n      if (index !== -1) {\n        const msgObject = action.payload;\n        state.socket.send(JSON.stringify(msgObject));\n\n        /* update listOfDms in state */\n        var updateListOfDms = state.listOfDms;\n        updateListOfDms[index].messages.push({\n          message: msgObject.message,\n          username: msgObject.user_id,\n        });\n       \n        return {\n          ...state,\n          listOfDms: updateListOfDms,\n        };\n      }\n      return state;\n    default:\n      return state;\n  }\n};\n\nexport default socketReducer;\n"]},"metadata":{},"sourceType":"module"}