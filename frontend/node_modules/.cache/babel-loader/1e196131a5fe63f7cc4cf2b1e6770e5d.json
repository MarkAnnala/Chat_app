{"ast":null,"code":"/*\n initialState is the state object that we send into the redux store and can manipulate with the reducers\n */\nconst initialState = {\n  socket: null,\n  wsOnline: false,\n  socketServer: null,\n  firstWelcome: null,\n  magicToken: null,\n  username: null,\n  listOfDms: null,\n  listOfFriends: null,\n  server: null\n};\n/**\n * helper function used by action type \"RESPONSE\" and action \"send_message\" to locate the correct dm object index\n * @param {array} list containing all direct messages of the user\n * @param {string} chatID used to identify the correct dm object\n *\n * @returns the index of the correct dm object\n */\n\nconst getChatIndex = (list, chatID) => {\n  let index = 0;\n\n  for (const chat of list) {\n    if (chat.chatID === chatID) {\n      return index;\n    }\n\n    index++;\n  }\n\n  return -1; // this line will only be reached if we give an invalid chatID\n};\n\nconst getThreadIndex = (thread_id, listOfThreads) => {\n  let index = 0;\n\n  for (const thread of listOfThreads) {\n    if (thread.id === thread_id) {\n      return index;\n    }\n\n    index++;\n  }\n\n  return -1;\n};\n/**\n * performs a task depending on the action.type dispatched - acts more as a middleware for socket handling\n *\n * !!! Reducers shouldn't do sideeffects which this one does - consider this one more as a middleware than a real reducer\n *\n * @param {object} state the current state that is being held by the redux store\n * @property {object} socket contains the actual socket that we communicate with\n * @property {bool} wsOnline is true when the socket is online (used to handle disconnects/time outs)\n * @property {string} socketServer the url of server that we create a websocket with\n * @property {bool} firstWelcome used to know if we've made our first repsonse to socket after login  (TODO maybe better way)\n * @property {array} listOfMessages holds all chatroom objects\n * @property {array} listOfFriends holds all friends usernames\n * @property {string} username holds the username of logged in user\n * @param {object} action contains the type and payload\n * @property {string} action.type what kind of action should the reducer do\n * @property {object} action.payload check actions.js for what it may contain\n *\n * @returns updated state\n */\n\n\nconst socketReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"CONNECT\":\n      /* store websocket in state.socket */\n      console.log(\"connecting to ws\");\n      var firstWelcome;\n\n      if (state.firstWelcome === null) {\n        firstWelcome = true;\n      } else {\n        firstWelcome = state.firstWelcome ? true : false;\n      }\n\n      return { ...state,\n        socket: new WebSocket(state.socketServer),\n        wsOnline: true,\n        firstWelcome: firstWelcome\n      };\n\n    case \"ADD_COMMENT\":\n      console.log(state.socket.explicitOriginalTarget);\n      state.socket.send(JSON.stringify(action.payload));\n      console.log(state.socket);\n      return state;\n\n    case \"CREATE_THREAD\":\n      state.socket.send(JSON.stringify(action.payload));\n      return state;\n\n    case \"ADD_THREADS\":\n      return { ...state,\n        server: { ...state.server,\n          listOfThreads: action.payload.threads\n        }\n      };\n\n    case \"ADDFRIEND\":\n      return { ...state,\n        listOfFriends: state.listOfFriends.concat(action.payload.username)\n      };\n\n    case \"CHAT_REQUEST\":\n      state.socket.send(JSON.stringify(action.payload));\n      return state;\n\n    case \"RESPONSE\":\n      /* if data is ack or welcome there's nothning we need to do */\n      if (action.payload.data === \"Welcome\" || action.payload.data === \"ACK\") {\n        return state;\n        /* first response */\n      } else if (action.payload.action === \"login\") {\n        /* need to respond to socket with action = login, username, and magictoken to establish connection */\n        state.socket.send(JSON.stringify(action.payload));\n        /* TODO TODO\n          This if and else cases handles the fact that we accidentely get 2 login responses from backend right now\n          not to trigger useEffect in ChatContainer we have this case here.. TODO remove it after backend fixes it\n        */\n\n        if (state.firstWelcome === false) {\n          console.log(\"Duplicate welcome login response...\");\n          return state;\n        } else {\n          console.log(\"first welcome login response\");\n          return { ...state,\n            firstWelcome: false,\n            // no longer first welcome..\n            magicToken: action.payload.magictoken.magic_token,\n\n            /* \n            TESTING -- TODO - HARDCODED the login object that we should get in accordance with doc\n            in accordance with doc it should be a response with action \"init_login\" but we will do \n            it here right now\n             */\n            listOfDms: [],\n            listOfFriends: [],\n            username: action.payload.username,\n\n            /* set hardcoded server oject with name of GLOBAL, empty thread list and member list with only urself */\n            server: {\n              serverName: \"0\",\n              serverInformation: \"\",\n              listOfThreads: [],\n              members: [action.payload.username]\n            }\n          };\n        }\n      } else {\n        const parsedData = JSON.parse(action.payload.data);\n        /* We respond differently depending on the action/type of received data */\n\n        switch (parsedData.action) {\n          case \"insert_comment\":\n            let iT = getThreadIndex(parsedData.thread_id, state.server.listOfThreads);\n            const threads = state.server.listOfThreads;\n            threads[iT].comments.push({\n              user_id: parsedData.username,\n              comment: parsedData.comment,\n              reply: parsedData.reply\n            });\n            return { ...state,\n              server: { ...state.server,\n                listOfThreads: threads\n              }\n            };\n\n          case \"init_login\":\n            console.log(parsedData);\n            var listOfDms = [];\n\n            for (let DM of parsedData.list_of_dms) {\n              if (DM.members.length == 2 && DM.members.includes(DM.chat_name)) {\n                let chatname = DM.members.filter(m => m != state.username)[0];\n                listOfDms.push({ ...DM,\n                  sinceLastSeen: 0,\n                  chatName: chatname\n                });\n              } else {\n                listOfDms.push({ ...DM,\n                  sinceLastSeen: 0\n                });\n              }\n            } //const listOfDms = parsedData.list_of_dms.map((obj) => {\n            //  return { ...obj, sinceLastSeen: 0 }; /* used for notifications */\n            //});\n\n\n            return { ...state,\n              listOfDms: listOfDms,\n              listOfFriends: parsedData.list_of_friends,\n              username: parsedData.user_id\n            };\n\n          case \"send_message\":\n            console.log(parsedData);\n            /* add the new msg object to the right dm object */\n\n            const index = getChatIndex(state.listOfDms, parsedData.chat_id);\n            return { ...state,\n              listOfDms: [...state.listOfDms, state.listOfDms[index].sinceLastSeen++, state.listOfDms[index].messages.push({\n                message: parsedData.message,\n                username: parsedData.user_id,\n                timestamp: parsedData.timestamp\n              })]\n            };\n\n          case \"chat_request\":\n            /* insert a new chat object to listOfDms */\n            if (parsedData.status === \"ok\") {\n              var chatname;\n\n              if (parsedData.members.lenght == 2 && parsedData.members.includes(parsedData.chat_name)) {\n                chatname = parsedData.members.filter(m => m != state.username)[0];\n              } else {\n                chatname = parsedData.chat_name;\n              }\n\n              return { ...state,\n                listOfDms: [...state.listOfDms,\n                /* newly inserted object */\n                {\n                  chatName: chatname,\n                  chatID: parsedData.chat_id,\n                  messages: [],\n                  members: parsedData.members,\n                  creator: parsedData.creator,\n                  sinceLastSeen: 0\n                  /* used for notifications */\n\n                }]\n              };\n            }\n\n            return state;\n\n          case \"create_thread\":\n            return { ...state,\n              server: { ...state.server,\n                listOfThreads: [...state.server.listOfThreads, {\n                  rootPost: {\n                    rootHeader: parsedData.root_post.root_header,\n                    rootComment: parsedData.root_post.root_comment\n                  },\n                  username: parsedData.username,\n                  timestamp: parsedData.timestamp,\n                  comments: parsedData.commentList,\n                  id: parsedData.thread_id\n                }]\n              }\n            };\n\n          default:\n            return state;\n        }\n      }\n\n    case \"DISCONNECTED\":\n      return { ...state,\n        socket: action.payload,\n        wsOnline: false,\n        firstWelcome: null,\n        listOfDms: null,\n        listOfFriends: null,\n        username: null\n      };\n\n    case \"SETSERVER\":\n      return { ...state,\n        socketServer: action.payload\n      };\n\n    case \"SENDMESSAGE\":\n      const index = getChatIndex(state.listOfDms, action.payload.chat_id);\n\n      if (index !== -1) {\n        const msgObject = action.payload;\n        state.socket.send(JSON.stringify(msgObject));\n        /* update listOfDms in state */\n\n        var updateListOfDms = state.listOfDms;\n        updateListOfDms[index].messages.push({\n          message: msgObject.message,\n          username: msgObject.user_id,\n          timestamp: msgObject.timestamp\n        });\n        return { ...state,\n          listOfDms: updateListOfDms\n        };\n      }\n\n      return state;\n\n    case \"LOGOUT\":\n      /* RESET STATE */\n      return { ...state,\n        socket: null,\n        wsOnline: false,\n        socketServer: null,\n        firstWelcome: null,\n        magicToken: null,\n        username: null,\n        listOfDms: null,\n        listOfFriends: null\n      };\n\n    case \"RESET_LAST_SEEN\":\n      /* Reset the since last seen counter to 0 */\n      const i = getChatIndex(state.listOfDms, action.payload.chatID);\n      const DMs = state.listOfDms;\n      DMs[i].sinceLastSeen = 0;\n      return { ...state,\n        listOfDms: DMs\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport default socketReducer;","map":{"version":3,"sources":["/Users/Mark/Documents/Skola/OSPP/adrenaline/frontend/src/reducers/socketReducer.js"],"names":["initialState","socket","wsOnline","socketServer","firstWelcome","magicToken","username","listOfDms","listOfFriends","server","getChatIndex","list","chatID","index","chat","getThreadIndex","thread_id","listOfThreads","thread","id","socketReducer","state","action","type","console","log","WebSocket","explicitOriginalTarget","send","JSON","stringify","payload","threads","concat","data","magictoken","magic_token","serverName","serverInformation","members","parsedData","parse","iT","comments","push","user_id","comment","reply","DM","list_of_dms","length","includes","chat_name","chatname","filter","m","sinceLastSeen","chatName","list_of_friends","chat_id","messages","message","timestamp","status","lenght","creator","rootPost","rootHeader","root_post","root_header","rootComment","root_comment","commentList","msgObject","updateListOfDms","i","DMs"],"mappings":"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","sourcesContent":["/*\n initialState is the state object that we send into the redux store and can manipulate with the reducers\n */\nconst initialState = {\n  socket: null,\n  wsOnline: false,\n  socketServer: null,\n  firstWelcome: null,\n  magicToken: null,\n  username: null,\n  listOfDms: null,\n  listOfFriends: null,\n  server: null,\n};\n\n/**\n * helper function used by action type \"RESPONSE\" and action \"send_message\" to locate the correct dm object index\n * @param {array} list containing all direct messages of the user\n * @param {string} chatID used to identify the correct dm object\n *\n * @returns the index of the correct dm object\n */\nconst getChatIndex = (list, chatID) => {\n  let index = 0;\n  for (const chat of list) {\n    if (chat.chatID === chatID) {\n      return index;\n    }\n    index++;\n  }\n  return -1; // this line will only be reached if we give an invalid chatID\n};\n\nconst getThreadIndex = (thread_id, listOfThreads) => {\n  let index = 0;\n  for (const thread of listOfThreads) {\n    if (thread.id === thread_id) {\n      return index;\n    }\n    index++;\n  }\n  return -1;\n};\n\n/**\n * performs a task depending on the action.type dispatched - acts more as a middleware for socket handling\n *\n * !!! Reducers shouldn't do sideeffects which this one does - consider this one more as a middleware than a real reducer\n *\n * @param {object} state the current state that is being held by the redux store\n * @property {object} socket contains the actual socket that we communicate with\n * @property {bool} wsOnline is true when the socket is online (used to handle disconnects/time outs)\n * @property {string} socketServer the url of server that we create a websocket with\n * @property {bool} firstWelcome used to know if we've made our first repsonse to socket after login  (TODO maybe better way)\n * @property {array} listOfMessages holds all chatroom objects\n * @property {array} listOfFriends holds all friends usernames\n * @property {string} username holds the username of logged in user\n * @param {object} action contains the type and payload\n * @property {string} action.type what kind of action should the reducer do\n * @property {object} action.payload check actions.js for what it may contain\n *\n * @returns updated state\n */\nconst socketReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"CONNECT\":\n      /* store websocket in state.socket */\n      console.log(\"connecting to ws\");\n      var firstWelcome;\n      if (state.firstWelcome === null) {\n        firstWelcome = true;\n      } else {\n        firstWelcome = state.firstWelcome ? true : false;\n      }\n      return {\n        ...state,\n        socket: new WebSocket(state.socketServer),\n        wsOnline: true,\n        firstWelcome: firstWelcome,\n      };\n    case \"ADD_COMMENT\":\n      console.log(state.socket.explicitOriginalTarget);\n      state.socket.send(JSON.stringify(action.payload));\n      console.log(state.socket);\n      return state;\n    case \"CREATE_THREAD\":\n      state.socket.send(JSON.stringify(action.payload));\n      return state;\n\n    case \"ADD_THREADS\":\n      return {\n        ...state,\n        server: {\n          ...state.server,\n          listOfThreads: action.payload.threads,\n        },\n      };\n    case \"ADDFRIEND\":\n      return {\n        ...state,\n        listOfFriends: state.listOfFriends.concat(action.payload.username),\n      };\n    case \"CHAT_REQUEST\":\n      state.socket.send(JSON.stringify(action.payload));\n      return state;\n    case \"RESPONSE\":\n      /* if data is ack or welcome there's nothning we need to do */\n      if (action.payload.data === \"Welcome\" || action.payload.data === \"ACK\") {\n        return state;\n\n        /* first response */\n      } else if (action.payload.action === \"login\") {\n        /* need to respond to socket with action = login, username, and magictoken to establish connection */\n\n        state.socket.send(JSON.stringify(action.payload));\n\n        /* TODO TODO\n          This if and else cases handles the fact that we accidentely get 2 login responses from backend right now\n          not to trigger useEffect in ChatContainer we have this case here.. TODO remove it after backend fixes it\n        */\n        if (state.firstWelcome === false) {\n          console.log(\"Duplicate welcome login response...\");\n          return state;\n        } else {\n          console.log(\"first welcome login response\");\n          return {\n            ...state,\n            firstWelcome: false, // no longer first welcome..\n            magicToken: action.payload.magictoken.magic_token,\n            /* \n            TESTING -- TODO - HARDCODED the login object that we should get in accordance with doc\n            in accordance with doc it should be a response with action \"init_login\" but we will do \n            it here right now\n\n            */\n            listOfDms: [],\n            listOfFriends: [],\n            username: action.payload.username,\n            /* set hardcoded server oject with name of GLOBAL, empty thread list and member list with only urself */\n            server: {\n              serverName: \"0\",\n              serverInformation: \"\",\n              listOfThreads: [],\n              members: [action.payload.username],\n            },\n          };\n        }\n      } else {\n        const parsedData = JSON.parse(action.payload.data);\n\n        /* We respond differently depending on the action/type of received data */\n        switch (parsedData.action) {\n          case \"insert_comment\":\n            let iT = getThreadIndex(\n              parsedData.thread_id,\n              state.server.listOfThreads\n            );\n            const threads = state.server.listOfThreads;\n            threads[iT].comments.push({\n              user_id: parsedData.username,\n              comment: parsedData.comment,\n              reply: parsedData.reply,\n            });\n            return {\n              ...state,\n              server: {\n                ...state.server,\n                listOfThreads: threads,\n              },\n            };\n          case \"init_login\":\n            console.log(parsedData);\n            var listOfDms = [];\n            for (let DM of parsedData.list_of_dms) {\n              if (\n                DM.members.length == 2 &&\n                DM.members.includes(DM.chat_name)\n              ) {\n                let chatname = DM.members.filter((m) => m != state.username)[0];\n                listOfDms.push({\n                  ...DM,\n                  sinceLastSeen: 0,\n                  chatName: chatname,\n                });\n              } else {\n                listOfDms.push({\n                  ...DM,\n                  sinceLastSeen: 0,\n                });\n              }\n            }\n            //const listOfDms = parsedData.list_of_dms.map((obj) => {\n            //  return { ...obj, sinceLastSeen: 0 }; /* used for notifications */\n            //});\n            return {\n              ...state,\n              listOfDms: listOfDms,\n              listOfFriends: parsedData.list_of_friends,\n              username: parsedData.user_id,\n            };\n          case \"send_message\":\n            console.log(parsedData);\n            /* add the new msg object to the right dm object */\n            const index = getChatIndex(state.listOfDms, parsedData.chat_id);\n            return {\n              ...state,\n              listOfDms: [\n                ...state.listOfDms,\n                state.listOfDms[index].sinceLastSeen++,\n                state.listOfDms[index].messages.push({\n                  message: parsedData.message,\n                  username: parsedData.user_id,\n                  timestamp: parsedData.timestamp,\n                }),\n              ],\n            };\n          case \"chat_request\":\n            /* insert a new chat object to listOfDms */\n            if (parsedData.status === \"ok\") {\n              var chatname;\n              if (\n                parsedData.members.lenght == 2 &&\n                parsedData.members.includes(parsedData.chat_name)\n              ) {\n                chatname = parsedData.members.filter(\n                  (m) => m != state.username\n                )[0];\n              } else {\n                chatname = parsedData.chat_name;\n              }\n              return {\n                ...state,\n                listOfDms: [\n                  ...state.listOfDms,\n                  /* newly inserted object */\n                  {\n                    chatName: chatname,\n                    chatID: parsedData.chat_id,\n                    messages: [],\n                    members: parsedData.members,\n                    creator: parsedData.creator,\n                    sinceLastSeen: 0 /* used for notifications */,\n                  },\n                ],\n              };\n            }\n            return state;\n          case \"create_thread\":\n            return {\n              ...state,\n              server: {\n                ...state.server,\n                listOfThreads: [\n                  ...state.server.listOfThreads,\n                  {\n                    rootPost: {\n                      rootHeader: parsedData.root_post.root_header,\n                      rootComment: parsedData.root_post.root_comment,\n                    },\n                    username: parsedData.username,\n                    timestamp: parsedData.timestamp,\n                    comments: parsedData.commentList,\n                    id: parsedData.thread_id,\n                  },\n                ],\n              },\n            };\n          default:\n            return state;\n        }\n      }\n\n    case \"DISCONNECTED\":\n      return {\n        ...state,\n        socket: action.payload,\n        wsOnline: false,\n        firstWelcome: null,\n        listOfDms: null,\n        listOfFriends: null,\n        username: null,\n      };\n\n    case \"SETSERVER\":\n      return { ...state, socketServer: action.payload };\n\n    case \"SENDMESSAGE\":\n      const index = getChatIndex(state.listOfDms, action.payload.chat_id);\n\n      if (index !== -1) {\n        const msgObject = action.payload;\n\n        state.socket.send(JSON.stringify(msgObject));\n\n        /* update listOfDms in state */\n        var updateListOfDms = state.listOfDms;\n        updateListOfDms[index].messages.push({\n          message: msgObject.message,\n          username: msgObject.user_id,\n          timestamp: msgObject.timestamp,\n        });\n\n        return {\n          ...state,\n          listOfDms: updateListOfDms,\n        };\n      }\n      return state;\n    case \"LOGOUT\":\n      /* RESET STATE */\n      return {\n        ...state,\n        socket: null,\n        wsOnline: false,\n        socketServer: null,\n        firstWelcome: null,\n        magicToken: null,\n        username: null,\n        listOfDms: null,\n        listOfFriends: null,\n      };\n    case \"RESET_LAST_SEEN\":\n      /* Reset the since last seen counter to 0 */\n      const i = getChatIndex(state.listOfDms, action.payload.chatID);\n      const DMs = state.listOfDms;\n      DMs[i].sinceLastSeen = 0;\n      return {\n        ...state,\n        listOfDms: DMs,\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport default socketReducer;\n"]},"metadata":{},"sourceType":"module"}