{"ast":null,"code":"/*\n initialState is the state object that we send into the redux store and can manipulate with the reducers\n */\nconst initialState = {\n  socket: null,\n  wsOnline: false,\n  socketServer: null,\n  firstWelcome: null,\n  latestMessage: null\n};\n/**\n * performs a task depending on the action.type dispatched - acts more as a middleware for socket handling\n *\n * !!! Reducers shouldn't do sideeffects which this one does - consider this one more as a middleware than a real reducer\n *\n * @param {object} state the current state that is being held by the redux store\n * @property {object} socket contains the actual socket that we communicate with\n * @property {bool} wsOnline is true when the socket is online (used to handle disconnects/time outs)\n * @property {string} socketServer the url of server that we create a websocket with\n * @property {bool} firstWelcome used to know if we've made our first repsonse to socket after login  (TODO maybe better way)\n * @property {object} latestMessage holds the latest message obj sent by another user. (TODO ONLY FOR THE PROTOTYPE!!!)\n *\n * @param {object} action contains the type and payload\n * @property {string} action.type what kind of action should the reducer do\n * @property {object} action.payload check actions.js for what it may contain\n *\n * @returns updated state\n */\n\nconst socketReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"CONNECT\":\n      /* store websocket in state.socket */\n      console.log(\"connecting to ws\");\n      return { ...state,\n        socket: new WebSocket(state.socketServer),\n        wsOnline: true,\n        firstWelcome: true,\n        latestMessage: null\n      };\n\n    case \"RESPONSE\":\n      /* if data is ack or welcome there's nothning we need to do */\n      if (action.payload.data === \"Welcome\" || action.payload.data === \"ACK\") {\n        return state;\n      } else if (action.payload.action === \"login\") {\n        /* first response */\n        state.socket.send(JSON.stringify(action.payload));\n        return { ...state,\n          firstWelcome: false\n        };\n      } else {\n        const parsedData = JSON.parse(action.payload.data);\n        /* We respond differently depending on the action/type of received data */\n\n        switch (parsedData.action) {\n          case \"send_message\":\n            return { ...state,\n              latestMessage: {\n                message: parsedData.message,\n                username: parsedData.user_id\n              }\n            };\n\n          default:\n            return state;\n        }\n      }\n\n    case \"DISCONNECTED\":\n      return { ...state,\n        socket: action.payload,\n        wsOnline: false,\n        firstWelcome: true\n      };\n\n    case \"SETSERVER\":\n      return { ...state,\n        socketServer: action.payload\n      };\n\n    case \"SENDMESSAGE\":\n      state.socket.send(JSON.stringify(action.payload));\n      return state;\n\n    default:\n      return state;\n  }\n};\n\nexport default socketReducer;","map":{"version":3,"sources":["/Users/Mark/Documents/Skola/OSPP/adrenaline/frontend/src/reducers/socketReducer.js"],"names":["initialState","socket","wsOnline","socketServer","firstWelcome","latestMessage","socketReducer","state","action","type","console","log","WebSocket","payload","data","send","JSON","stringify","parsedData","parse","message","username","user_id"],"mappings":"AAAA;;;AAGA,MAAMA,YAAY,GAAG;AACnBC,EAAAA,MAAM,EAAE,IADW;AAEnBC,EAAAA,QAAQ,EAAE,KAFS;AAGnBC,EAAAA,YAAY,EAAE,IAHK;AAInBC,EAAAA,YAAY,EAAE,IAJK;AAKnBC,EAAAA,aAAa,EAAE;AALI,CAArB;AAQA;;;;;;;;;;;;;;;;;;;AAkBA,MAAMC,aAAa,GAAG,CAACC,KAAK,GAAGP,YAAT,EAAuBQ,MAAvB,KAAkC;AACtD,UAAQA,MAAM,CAACC,IAAf;AACE,SAAK,SAAL;AACE;AACAC,MAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ;AACA,aAAO,EACL,GAAGJ,KADE;AAELN,QAAAA,MAAM,EAAE,IAAIW,SAAJ,CAAcL,KAAK,CAACJ,YAApB,CAFH;AAGLD,QAAAA,QAAQ,EAAE,IAHL;AAILE,QAAAA,YAAY,EAAE,IAJT;AAKLC,QAAAA,aAAa,EAAE;AALV,OAAP;;AAQF,SAAK,UAAL;AACE;AACA,UAAIG,MAAM,CAACK,OAAP,CAAeC,IAAf,KAAwB,SAAxB,IAAqCN,MAAM,CAACK,OAAP,CAAeC,IAAf,KAAwB,KAAjE,EAAwE;AACtE,eAAOP,KAAP;AACD,OAFD,MAEO,IAAIC,MAAM,CAACK,OAAP,CAAeL,MAAf,KAA0B,OAA9B,EAAuC;AAC5C;AACAD,QAAAA,KAAK,CAACN,MAAN,CAAac,IAAb,CAAkBC,IAAI,CAACC,SAAL,CAAeT,MAAM,CAACK,OAAtB,CAAlB;AACA,eAAO,EAAE,GAAGN,KAAL;AAAYH,UAAAA,YAAY,EAAE;AAA1B,SAAP;AACD,OAJM,MAIA;AACL,cAAMc,UAAU,GAAGF,IAAI,CAACG,KAAL,CAAWX,MAAM,CAACK,OAAP,CAAeC,IAA1B,CAAnB;AAEA;;AACA,gBAAQI,UAAU,CAACV,MAAnB;AACE,eAAK,cAAL;AACE,mBAAO,EACL,GAAGD,KADE;AAELF,cAAAA,aAAa,EAAE;AACbe,gBAAAA,OAAO,EAAEF,UAAU,CAACE,OADP;AAEbC,gBAAAA,QAAQ,EAAEH,UAAU,CAACI;AAFR;AAFV,aAAP;;AAOF;AACE,mBAAOf,KAAP;AAVJ;AAYD;;AAEH,SAAK,cAAL;AACE,aAAO,EAAE,GAAGA,KAAL;AAAYN,QAAAA,MAAM,EAAEO,MAAM,CAACK,OAA3B;AAAoCX,QAAAA,QAAQ,EAAE,KAA9C;AAAqDE,QAAAA,YAAY,EAAG;AAApE,OAAP;;AAEF,SAAK,WAAL;AACE,aAAO,EAAE,GAAGG,KAAL;AAAYJ,QAAAA,YAAY,EAAEK,MAAM,CAACK;AAAjC,OAAP;;AAEF,SAAK,aAAL;AACEN,MAAAA,KAAK,CAACN,MAAN,CAAac,IAAb,CAAkBC,IAAI,CAACC,SAAL,CAAeT,MAAM,CAACK,OAAtB,CAAlB;AACA,aAAON,KAAP;;AAEF;AACE,aAAOA,KAAP;AAjDJ;AAmDD,CApDD;;AAsDA,eAAeD,aAAf","sourcesContent":["/*\n initialState is the state object that we send into the redux store and can manipulate with the reducers\n */\nconst initialState = {\n  socket: null,\n  wsOnline: false,\n  socketServer: null,\n  firstWelcome: null,\n  latestMessage: null,\n};\n\n/**\n * performs a task depending on the action.type dispatched - acts more as a middleware for socket handling\n *\n * !!! Reducers shouldn't do sideeffects which this one does - consider this one more as a middleware than a real reducer\n *\n * @param {object} state the current state that is being held by the redux store\n * @property {object} socket contains the actual socket that we communicate with\n * @property {bool} wsOnline is true when the socket is online (used to handle disconnects/time outs)\n * @property {string} socketServer the url of server that we create a websocket with\n * @property {bool} firstWelcome used to know if we've made our first repsonse to socket after login  (TODO maybe better way)\n * @property {object} latestMessage holds the latest message obj sent by another user. (TODO ONLY FOR THE PROTOTYPE!!!)\n *\n * @param {object} action contains the type and payload\n * @property {string} action.type what kind of action should the reducer do\n * @property {object} action.payload check actions.js for what it may contain\n *\n * @returns updated state\n */\nconst socketReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"CONNECT\":\n      /* store websocket in state.socket */\n      console.log(\"connecting to ws\");\n      return {\n        ...state,\n        socket: new WebSocket(state.socketServer),\n        wsOnline: true,\n        firstWelcome: true,\n        latestMessage: null,\n      };\n\n    case \"RESPONSE\":\n      /* if data is ack or welcome there's nothning we need to do */\n      if (action.payload.data === \"Welcome\" || action.payload.data === \"ACK\") {\n        return state;\n      } else if (action.payload.action === \"login\") {\n        /* first response */\n        state.socket.send(JSON.stringify(action.payload));\n        return { ...state, firstWelcome: false };\n      } else {\n        const parsedData = JSON.parse(action.payload.data);\n\n        /* We respond differently depending on the action/type of received data */\n        switch (parsedData.action) {\n          case \"send_message\":\n            return {\n              ...state,\n              latestMessage: {\n                message: parsedData.message,\n                username: parsedData.user_id,\n              },\n            };\n          default:\n            return state;\n        }\n      }\n\n    case \"DISCONNECTED\":\n      return { ...state, socket: action.payload, wsOnline: false, firstWelcome : true };\n\n    case \"SETSERVER\":\n      return { ...state, socketServer: action.payload };\n\n    case \"SENDMESSAGE\":\n      state.socket.send(JSON.stringify(action.payload));\n      return state;\n\n    default:\n      return state;\n  }\n};\n\nexport default socketReducer;\n"]},"metadata":{},"sourceType":"module"}