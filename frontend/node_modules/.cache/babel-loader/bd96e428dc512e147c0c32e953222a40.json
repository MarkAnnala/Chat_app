{"ast":null,"code":"/*\n initialState is the state object that we send into the redux store and can manipulate with the reducers\n */\nconst initialState = {\n  socket: null,\n  wsOnline: false,\n  socketServer: null,\n  firstWelcome: null,\n  listOfDms: null\n};\n/**\n * helper function used by action type SENDMESSAGE to locate the correct chat id\n * @param {array} list containing all direct messages of the user\n * @param {string} chatName used to identify the correct dm object\n *\n * @returns the chatID of the dm object\n */\n\nconst getChatID = (list, chatName) => {\n  let index = 0;\n\n  for (const chat of list) {\n    if (chat.chatName === chatName) {\n      return [chat.chatID, index];\n    }\n\n    index++;\n  }\n\n  return [null, -1]; // this line will only be reached if we give an invalid chatName\n};\n/**\n * helper function used by action type \"RESPONSE\" and action \"send_message\" to locate the correct dm object index\n * @param {array} list containing all direct messages of the user\n * @param {string} chatID used to identify the correct dm object\n *\n * @returns the index of the correct dm object\n */\n\n\nconst getChatIndex = (list, chatID) => {\n  let index = 0;\n\n  for (const chat of list) {\n    if (chat.chatID === chatID) {\n      return index;\n    }\n\n    index++;\n  }\n\n  return -1; // this line will only be reached if we give an invalid chatID\n};\n/**\n * performs a task depending on the action.type dispatched - acts more as a middleware for socket handling\n *\n * !!! Reducers shouldn't do sideeffects which this one does - consider this one more as a middleware than a real reducer\n *\n * @param {object} state the current state that is being held by the redux store\n * @property {object} socket contains the actual socket that we communicate with\n * @property {bool} wsOnline is true when the socket is online (used to handle disconnects/time outs)\n * @property {string} socketServer the url of server that we create a websocket with\n * @property {bool} firstWelcome used to know if we've made our first repsonse to socket after login  (TODO maybe better way)\n * @property {object} latestMessage holds the latest message obj sent by another user. (TODO ONLY FOR THE PROTOTYPE!!!)\n *  @property {array} listOfMessages holds all chatroom objects TODO!\n * @param {object} action contains the type and payload\n * @property {string} action.type what kind of action should the reducer do\n * @property {object} action.payload check actions.js for what it may contain\n * @property {object} action.identifier used for identifying something inside state object .. eg: chatID of specific chat\n *\n * @returns updated state\n */\n\n\nconst socketReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"CONNECT\":\n      /* store websocket in state.socket */\n      console.log(\"connecting to ws\");\n      return { ...state,\n        socket: new WebSocket(state.socketServer),\n        wsOnline: true,\n        firstWelcome: true\n      };\n\n    case \"RESPONSE\":\n      /* if data is ack or welcome there's nothning we need to do */\n      if (action.payload.data === \"Welcome\" || action.payload.data === \"ACK\") {\n        return state;\n      } else if (action.payload.action === \"login\") {\n        /* first response */\n        console.log(state);\n        state.socket.send(JSON.stringify(action.payload));\n        return { ...state,\n          firstWelcome: false,\n\n          /* \n          TESTING -- each user gets 2 hard coded chatrooms on login\n                     perhaps something like this will work on login.. \n                     database sends user a list of all its chat rooms with the stored messages in correct order..  \n          */\n          listOfDms: [{\n            chatName: \"Skooben\",\n            chatID: \"1a\",\n            messages: [{\n              message: \"test\",\n              username: \"Markipie\"\n            }]\n          }, {\n            chatName: \"Grabbarna Grus\",\n            chatID: \"2a\",\n            messages: [{\n              message: \"Axel mitt sexdjur?\",\n              username: \"Anton\"\n            }, {\n              message: \"axel e arg p√• dig\",\n              username: \"Axel\"\n            }]\n          }]\n        };\n      } else {\n        const parsedData = JSON.parse(action.payload.data);\n        /* We respond differently depending on the action/type of received data */\n\n        switch (parsedData.action) {\n          case \"send_message\":\n            /* add the new msg object to the right dm object */\n            const index = getChatIndex(state.listOfDms, parsedData.chat_id);\n            return { ...state,\n              listOfDms: [...state.listOfDms, state.listOfDms[index].messages.push({\n                message: parsedData.message,\n                username: parsedData.user_id\n              })]\n            };\n\n          default:\n            return state;\n        }\n      }\n\n    case \"DISCONNECTED\":\n      return { ...state,\n        socket: action.payload,\n        wsOnline: false,\n        firstWelcome: true\n      };\n\n    case \"SETSERVER\":\n      return { ...state,\n        socketServer: action.payload\n      };\n\n    case \"SENDMESSAGE\":\n      const [chatID, index] = getChatID(state.listOfDms, action.identifier);\n\n      if (chatID !== null && index !== -1) {\n        const msgObject = { ...action.payload,\n          chat_id: chatID\n        };\n        state.socket.send(JSON.stringify(msgObject));\n        /* update listOfDms in state */\n\n        return { ...state,\n          listOfDms: [...state.listOfDms, state.listOfDms[index].messages.push({\n            message: msgObject.message,\n            username: msgObject.user_id\n          })]\n        };\n      }\n\n      return state;\n\n    case \"CHAT_REQUEST\":\n      state.socket.send(JSON.stringify(action.payload));\n      return state;\n\n    default:\n      return state;\n  }\n};\n\nexport default socketReducer;","map":{"version":3,"sources":["/Users/Mark/Documents/Skola/OSPP/adrenaline/frontend/src/reducers/socketReducer.js"],"names":["initialState","socket","wsOnline","socketServer","firstWelcome","listOfDms","getChatID","list","chatName","index","chat","chatID","getChatIndex","socketReducer","state","action","type","console","log","WebSocket","payload","data","send","JSON","stringify","messages","message","username","parsedData","parse","chat_id","push","user_id","identifier","msgObject"],"mappings":"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","sourcesContent":["/*\n initialState is the state object that we send into the redux store and can manipulate with the reducers\n */\nconst initialState = {\n  socket: null,\n  wsOnline: false,\n  socketServer: null,\n  firstWelcome: null,\n  listOfDms: null,\n};\n\n/**\n * helper function used by action type SENDMESSAGE to locate the correct chat id\n * @param {array} list containing all direct messages of the user\n * @param {string} chatName used to identify the correct dm object\n *\n * @returns the chatID of the dm object\n */\nconst getChatID = (list, chatName) => {\n  let index = 0;\n  for (const chat of list) {\n    if (chat.chatName === chatName) {\n      return [chat.chatID, index];\n    }\n    index++;\n  }\n  return [null, -1]; // this line will only be reached if we give an invalid chatName\n};\n/**\n * helper function used by action type \"RESPONSE\" and action \"send_message\" to locate the correct dm object index\n * @param {array} list containing all direct messages of the user\n * @param {string} chatID used to identify the correct dm object\n *\n * @returns the index of the correct dm object\n */\nconst getChatIndex = (list, chatID) => {\n  let index = 0;\n  for (const chat of list) {\n    if (chat.chatID === chatID) {\n      return index;\n    }\n    index++;\n  }\n  return -1; // this line will only be reached if we give an invalid chatID\n};\n\n/**\n * performs a task depending on the action.type dispatched - acts more as a middleware for socket handling\n *\n * !!! Reducers shouldn't do sideeffects which this one does - consider this one more as a middleware than a real reducer\n *\n * @param {object} state the current state that is being held by the redux store\n * @property {object} socket contains the actual socket that we communicate with\n * @property {bool} wsOnline is true when the socket is online (used to handle disconnects/time outs)\n * @property {string} socketServer the url of server that we create a websocket with\n * @property {bool} firstWelcome used to know if we've made our first repsonse to socket after login  (TODO maybe better way)\n * @property {object} latestMessage holds the latest message obj sent by another user. (TODO ONLY FOR THE PROTOTYPE!!!)\n *  @property {array} listOfMessages holds all chatroom objects TODO!\n * @param {object} action contains the type and payload\n * @property {string} action.type what kind of action should the reducer do\n * @property {object} action.payload check actions.js for what it may contain\n * @property {object} action.identifier used for identifying something inside state object .. eg: chatID of specific chat\n *\n * @returns updated state\n */\nconst socketReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"CONNECT\":\n      /* store websocket in state.socket */\n      console.log(\"connecting to ws\");\n      return {\n        ...state,\n        socket: new WebSocket(state.socketServer),\n        wsOnline: true,\n        firstWelcome: true,\n      };\n\n    case \"RESPONSE\":\n      /* if data is ack or welcome there's nothning we need to do */\n      if (action.payload.data === \"Welcome\" || action.payload.data === \"ACK\") {\n        return state;\n      } else if (action.payload.action === \"login\") {\n        /* first response */\n        console.log(state);\n        state.socket.send(JSON.stringify(action.payload));\n\n        return {\n          ...state,\n          firstWelcome: false,\n          /* \n          TESTING -- each user gets 2 hard coded chatrooms on login\n                     perhaps something like this will work on login.. \n                     database sends user a list of all its chat rooms with the stored messages in correct order..  \n          */\n          listOfDms: [\n            {\n              chatName: \"Skooben\",\n              chatID: \"1a\",\n              messages: [{ message: \"test\", username: \"Markipie\" }],\n            },\n            {\n              chatName: \"Grabbarna Grus\",\n              chatID: \"2a\",\n              messages: [\n                { message: \"Axel mitt sexdjur?\", username: \"Anton\" },\n                { message: \"axel e arg p√• dig\", username: \"Axel\" },\n              ],\n            },\n          ],\n        };\n      } else {\n        const parsedData = JSON.parse(action.payload.data);\n\n        /* We respond differently depending on the action/type of received data */\n        switch (parsedData.action) {\n          case \"send_message\":\n            /* add the new msg object to the right dm object */\n            const index = getChatIndex(state.listOfDms, parsedData.chat_id);\n            return {\n              ...state,\n              listOfDms: [\n                ...state.listOfDms,\n                state.listOfDms[index].messages.push({\n                  message: parsedData.message,\n                  username: parsedData.user_id,\n                }),\n              ],\n            };\n          default:\n            return state;\n        }\n      }\n\n    case \"DISCONNECTED\":\n      return {\n        ...state,\n        socket: action.payload,\n        wsOnline: false,\n        firstWelcome: true,\n      };\n\n    case \"SETSERVER\":\n      return { ...state, socketServer: action.payload };\n\n    case \"SENDMESSAGE\":\n      const [chatID, index] = getChatID(state.listOfDms, action.identifier);\n\n      if (chatID !== null && index !== -1) {\n        const msgObject = { ...action.payload, chat_id: chatID };\n        state.socket.send(JSON.stringify(msgObject));\n        /* update listOfDms in state */\n        return {\n          ...state,\n          listOfDms: [\n            ...state.listOfDms,\n            state.listOfDms[index].messages.push({\n              message: msgObject.message,\n              username: msgObject.user_id,\n            }),\n          ],\n        };\n      }\n      return state;\n      \n    case \"CHAT_REQUEST\": \n      state.socket.send(JSON.stringify(action.payload));\n      return state;\n    default:\n      return state;\n  }\n};\n\nexport default socketReducer;\n"]},"metadata":{},"sourceType":"module"}